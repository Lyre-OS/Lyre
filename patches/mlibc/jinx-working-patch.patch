diff --git mlibc-clean/.github/workflows/ci.yml mlibc-workdir/.github/workflows/ci.yml
index 0efc50c..56d4772 100644
--- mlibc-clean/.github/workflows/ci.yml
+++ mlibc-workdir/.github/workflows/ci.yml
@@ -84,7 +84,7 @@ jobs:
     compile-sysdeps:
         strategy:
             matrix:
-                sysdeps: [dripos, lemon, aero, ironclad, keyronex, managarm, vinix, astral]
+                sysdeps: [dripos, lemon, aero, ironclad, lyre, keyronex, managarm, vinix, astral]
         name: Compile sysdeps
         runs-on: ubuntu-22.04
         container:
diff --git mlibc-workdir/abis/lyre/reboot.h mlibc-workdir/abis/lyre/reboot.h
new file mode 100644
index 0000000..01bccec
--- /dev/null
+++ mlibc-workdir/abis/lyre/reboot.h
@@ -0,0 +1,12 @@
+#ifndef _ABIBITS_REBOOT_H
+#define _ABIBITS_REBOOT_H
+
+#define RB_AUTOBOOT 0x01234567
+#define RB_HALT_SYSTEM 0xcdef0123
+#define RB_ENABLE_CAD 0x89abcdef
+#define RB_DISABLE_CAD 0
+#define RB_POWER_OFF 0x4321fedc
+#define RB_SW_SUSPEND 0xd000fce2
+#define RB_KEXEC 0x45584543
+
+#endif /* _ABIBITS_REBOOT_H */
diff --git mlibc-workdir/abis/lyre/sigevent.h mlibc-workdir/abis/lyre/sigevent.h
new file mode 100644
index 0000000..d764178
--- /dev/null
+++ mlibc-workdir/abis/lyre/sigevent.h
@@ -0,0 +1,24 @@
+#ifndef _ABIBITS_SIGEVENT_H
+#define _ABIBITS_SIGEVENT_H
+
+#include <abi-bits/sigval.h>
+#include <abi-bits/pid_t.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct sigevent {
+	int sigev_notify;
+	int sigev_signo;
+	union sigval sigev_value;
+	void (*sigev_notify_function)(union sigval);
+	/* MISSING: sigev_notify_attributes */
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SIGEVENT_H */
+
diff --git mlibc-workdir/abis/lyre/signal.h mlibc-workdir/abis/lyre/signal.h
new file mode 100644
index 0000000..8626400
--- /dev/null
+++ mlibc-workdir/abis/lyre/signal.h
@@ -0,0 +1,179 @@
+#ifndef _ABIBITS_SIGNAL_H
+#define _ABIBITS_SIGNAL_H
+
+#include <abi-bits/pid_t.h>
+#include <abi-bits/uid_t.h>
+#include <abi-bits/sigevent.h>
+#include <bits/size_t.h>
+
+typedef struct {
+	int si_signo;
+	int si_code;
+	int si_errno;
+	pid_t si_pid;
+	uid_t si_uid;
+	void *si_addr;
+	int si_status;
+	union sigval si_value;
+} siginfo_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Argument for signal() */
+typedef void (*__sighandler) (int);
+
+#define SIG_ERR ((__sighandler)(void *)(-1))
+#define SIG_DFL ((__sighandler)(void *)(-2))
+#define SIG_IGN ((__sighandler)(void *)(-3))
+
+#define SIGHUP 1
+#define SIGINT 2
+#define SIGQUIT 3
+#define SIGILL 4
+#define SIGTRAP 5
+#define SIGABRT 6
+#define SIGBUS 7
+#define SIGFPE 8
+#define SIGKILL 9
+#define SIGUSR1 10
+#define SIGSEGV 11
+#define SIGUSR2 12
+#define SIGPIPE 13
+#define SIGALRM 14
+#define SIGTERM 15
+#define SIGSTKFLT 16
+#define SIGCHLD 17
+#define SIGCONT 18
+#define SIGSTOP 19
+#define SIGTSTP 20
+#define SIGTTIN 21
+#define SIGTTOU 22
+#define SIGURG 23
+#define SIGXCPU 24
+#define SIGXFSZ 25
+#define SIGVTALRM 26
+#define SIGPROF 27
+#define SIGWINCH 28
+#define SIGIO 29
+#define SIGPOLL SIGIO
+#define SIGPWR 30
+#define SIGSYS 31
+#define SIGRTMIN 32
+#define SIGRTMAX 33
+#define SIGCANCEL 34
+
+/* siginfo->si_info constants */
+/* SIGBUS */
+#define BUS_ADRALN 1
+#define BUS_ADRERR 2
+#define BUS_OBJERR 3
+
+/* SIGILL */
+#define ILL_ILLOPC 1
+#define ILL_ILLOPN 2
+#define ILL_ILLADR 3
+#define ILL_ILLTRP 4
+#define ILL_PRVOPC 5
+#define ILL_PRVREG 6
+#define ILL_COPROC 7
+#define ILL_BADSTK 8
+#define ILL_BADIADDR 9
+
+/* SIGSEGV */
+#define SEGV_MAPERR 1
+#define SEGV_ACCERR 2
+
+/* TODO: replace this by uint64_t */
+typedef long sigset_t;
+
+#define SIGUNUSED SIGSYS
+
+/* constants for sigprocmask() */
+#define SIG_BLOCK 1
+#define SIG_UNBLOCK 2
+#define SIG_SETMASK 3
+
+#define SA_NOCLDSTOP (1 << 0)
+#define SA_ONSTACK (1 << 1)
+#define SA_RESETHAND (1 << 2)
+#define SA_RESTART (1 << 3)
+#define SA_SIGINFO (1 << 4)
+#define SA_NOCLDWAIT (1 << 5)
+#define SA_NODEFER (1 << 6)
+
+#define MINSIGSTKSZ 2048
+#define SIGSTKSZ 8192
+#define SS_ONSTACK 1
+#define SS_DISABLE 2
+
+typedef struct __stack {
+	void *ss_sp;
+	size_t ss_size;
+	int ss_flags;
+} stack_t;
+
+/* constants for sigev_notify of struct sigevent */
+#define SIGEV_NONE 1
+#define SIGEV_SIGNAL 2
+#define SIGEV_THREAD 3
+
+#define SI_ASYNCNL (-60)
+#define SI_TKILL (-6)
+#define SI_SIGIO (-5)
+#define SI_ASYNCIO (-4)
+#define SI_MESGQ (-3)
+#define SI_TIMER (-2)
+#define SI_QUEUE (-1)
+#define SI_USER 0
+#define SI_KERNEL 128
+
+#define NSIG 65
+
+#define CLD_EXITED 1
+#define CLD_KILLED 2
+#define CLD_DUMPED 3
+#define CLD_TRAPPED 4
+#define CLD_STOPPED 5
+#define CLD_CONTINUED 6
+
+struct sigaction {
+	union {
+		void (*sa_handler)(int);
+		void (*sa_sigaction)(int, siginfo_t *, void *);
+	};
+	sigset_t sa_mask;
+	int sa_flags;
+};
+
+#if defined(__x86_64__) || defined(__aarch64__)
+/* TODO: This is wrong for AArch64. */
+
+typedef struct {
+	unsigned long oldmask;
+	unsigned long gregs[16];
+	unsigned long pc, pr, sr;
+	unsigned long gbr, mach, macl;
+	unsigned long fpregs[16];
+	unsigned long xfpregs[16];
+	unsigned int fpscr, fpul, ownedfp;
+} mcontext_t;
+
+typedef struct __ucontext {
+	unsigned long uc_flags;
+	struct __ucontext *uc_link;
+	stack_t uc_stack;
+	mcontext_t uc_mcontext;
+	sigset_t uc_sigmask;
+} ucontext_t;
+
+#else
+#error "Missing architecture specific code."
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ABIBITS_SIGNAL_H */
diff --git mlibc-workdir/abis/lyre/statvfs.h mlibc-workdir/abis/lyre/statvfs.h
new file mode 100644
index 0000000..370fcc1
--- /dev/null
+++ mlibc-workdir/abis/lyre/statvfs.h
@@ -0,0 +1,36 @@
+#ifndef _ABIBITS_STATVFS_H
+#define _ABIBITS_STATVFS_H
+
+#include <abi-bits/fsblkcnt_t.h>
+#include <abi-bits/fsfilcnt_t.h>
+
+#define ST_RDONLY 1
+#define ST_NOSUID 2
+#define ST_MANDLOCK 64
+
+#define FSTYPSZ 16
+
+/* On Linux, this struct is not directly used by the kernel. */
+struct statvfs {
+	unsigned long f_bsize;
+	unsigned long f_frsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsfilcnt_t f_favail;
+
+	unsigned long f_fsid;
+	char f_basetype[FSTYPSZ];
+
+	unsigned long f_flag;
+	unsigned long f_namemax;
+	char f_fstr[32];
+	unsigned long f_filler[16];
+};
+
+#endif /* _ABIBITS_STATVFS_H */
+
+
diff --git mlibc-workdir/ci/lyre.cross-file mlibc-workdir/ci/lyre.cross-file
new file mode 100644
index 0000000..1d4cd70
--- /dev/null
+++ mlibc-workdir/ci/lyre.cross-file
@@ -0,0 +1,12 @@
+[binaries]
+c = 'x86_64-linux-mlibc-gcc'
+cpp = 'x86_64-linux-mlibc-g++'
+
+[properties]
+needs_exe_wrapper = true
+
+[host_machine]
+system = 'lyre'
+cpu_family = 'x86_64'
+cpu = 'x86_64'
+endian = 'little'
diff --git mlibc-clean/meson.build mlibc-workdir/meson.build
index a460a6d..bfbcc02 100644
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -248,6 +248,10 @@ elif host_machine.system() == 'vinix'
 	rtld_include_dirs += include_directories('sysdeps/vinix/include')
 	libc_include_dirs += include_directories('sysdeps/vinix/include')
 	subdir('sysdeps/vinix')
+elif host_machine.system() == 'lyre'
+	rtld_include_dirs += include_directories('sysdeps/lyre/include')
+	libc_include_dirs += include_directories('sysdeps/lyre/include')
+	subdir('sysdeps/lyre')
 elif host_machine.system() == 'lemon'
 	rtld_include_dirs += include_directories('sysdeps/lemon/include')
 	libc_include_dirs += include_directories('sysdeps/lemon/include')
diff --git mlibc-workdir/sysdeps/lyre/.clang-format mlibc-workdir/sysdeps/lyre/.clang-format
new file mode 100644
index 0000000..4662692
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/.clang-format
@@ -0,0 +1,2 @@
+---
+DisableFormat: true
diff --git mlibc-workdir/sysdeps/lyre/generic/entry.cpp mlibc-workdir/sysdeps/lyre/generic/entry.cpp
new file mode 100644
index 0000000..f58dfc8
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/entry.cpp
@@ -0,0 +1,102 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/elf/startup.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <bits/posix/posix_signal.h>
+#include <lyre/syscall.h>
+
+extern "C" void __dlapi_enter(uintptr_t *);
+
+extern char **environ;
+
+struct GPRState {
+	uint64_t ds;
+	uint64_t es;
+	uint64_t rax;
+	uint64_t rbx;
+	uint64_t rcx;
+	uint64_t rdx;
+	uint64_t rsi;
+	uint64_t rdi;
+	uint64_t rbp;
+	uint64_t r8;
+	uint64_t r9;
+	uint64_t r10;
+	uint64_t r11;
+	uint64_t r12;
+	uint64_t r13;
+	uint64_t r14;
+	uint64_t r15;
+	uint64_t err;
+	uint64_t rip;
+	uint64_t cs;
+	uint64_t rflags;
+	uint64_t rsp;
+	uint64_t ss;
+};
+
+namespace mlibc {
+	int sys_sigentry(void *sigentry) {
+		__syscall_ret ret = __syscall(27, sigentry);
+		if (ret.errno != 0)
+			return ret.errno;
+		return 0;
+	}
+
+	[[noreturn]] int sys_sigreturn(void *context, sigset_t old_mask) {
+		__syscall(30, context, old_mask);
+		__builtin_unreachable();
+	}
+}
+
+static void __mlibc_sigentry(int which, siginfo_t *siginfo,
+		void (*sa)(int, siginfo_t *, void *),
+		GPRState *ret_context, sigset_t prev_mask) {
+
+/*
+	size_t *base_ptr = (size_t *)ret_context->rbp;
+
+	mlibc::infoLogger() << "Stacktrace:" << frg::endlog;
+	mlibc::infoLogger() << "  [" << (void *)ret_context->rip << "]" << frg::endlog;
+	for (;;) {
+		size_t old_bp = base_ptr[0];
+		size_t ret_addr = base_ptr[1];
+		if (!ret_addr)
+			break;
+		size_t off;
+		mlibc::infoLogger() << "  [" << (void *)ret_addr << "]" << frg::endlog;
+		if (!old_bp)
+			break;
+		base_ptr = (size_t *)old_bp;
+	}
+*/
+
+	switch ((uintptr_t)sa) {
+		// DFL
+		case (uintptr_t)(-2):
+			mlibc::infoLogger() << "mlibc: Unhandled signal " << which << frg::endlog;
+			mlibc::sys_exit(128 + which);
+		// IGN
+		case (uintptr_t)(-3):
+			break;
+		default:
+			sa(which, siginfo, NULL);
+			break;
+	}
+
+	mlibc::sys_sigreturn(ret_context, prev_mask);
+
+	__builtin_unreachable();
+}
+
+extern "C" void __mlibc_entry(uintptr_t *entry_stack, int (*main_fn)(int argc, char *argv[], char *env[])) {
+	__dlapi_enter(entry_stack);
+
+	//mlibc::sys_sigentry((void *)__mlibc_sigentry);
+
+	auto result = main_fn(mlibc::entry_stack.argc, mlibc::entry_stack.argv, environ);
+	exit(result);
+}
+
diff --git mlibc-workdir/sysdeps/lyre/generic/generic.cpp mlibc-workdir/sysdeps/lyre/generic/generic.cpp
new file mode 100644
index 0000000..0b53f66
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/generic.cpp
@@ -0,0 +1,856 @@
+#include <bits/ensure.h>
+#include <mlibc/allocator.hpp>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <asm/ioctls.h>
+#include <stdlib.h>
+#include <abi-bits/fcntl.h>
+#include <lyre/syscall.h>
+#include <frg/hash.hpp>
+#include <frg/hash_map.hpp>
+
+#define STRINGIFY_(X) #X
+#define STRINGIFY(X) STRINGIFY_(X)
+#define STUB_ONLY { \
+	sys_libc_log("STUB_ONLY function on line " STRINGIFY(__LINE__) " was called"); \
+	sys_libc_panic(); \
+}
+
+namespace {
+
+int fcntl_helper(int fd, int request, int *result, ...) {
+	va_list args;
+	va_start(args, result);
+	if(!mlibc::sys_fcntl) {
+		return ENOSYS;
+	}
+	int ret = mlibc::sys_fcntl(fd, request, args, result);
+	va_end(args);
+	return ret;
+}
+
+}
+
+namespace mlibc {
+
+void sys_libc_log(const char *message) {
+	__syscall(SYS_debug, message);
+}
+
+void sys_libc_panic() {
+	sys_libc_log("\nMLIBC PANIC\n");
+	sys_exit(1);
+	__builtin_unreachable();
+}
+
+void sys_exit(int status) {
+	__syscall(SYS_exit, status);
+	__builtin_unreachable();
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+[[noreturn]] void sys_thread_exit() {
+	__syscall(SYS_exit_thread);
+	__builtin_unreachable();
+}
+
+extern "C" void __mlibc_thread_entry();
+
+int sys_clone(void *tcb, pid_t *pid_out, void *stack) {
+	(void)tcb;
+
+	__syscall_ret ret = __syscall(SYS_new_thread, (uintptr_t)__mlibc_thread_entry, (uintptr_t)stack);
+	int ret_value = (int)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+
+	*pid_out = ret_value;
+	return 0;
+}
+
+int sys_kill(pid_t, int) STUB_ONLY
+
+int sys_tcgetattr(int fd, struct termios *attr) {
+	int ret;
+	if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
+		return r;
+	}
+	return 0;
+}
+
+int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
+	int ret;
+	switch (optional_action) {
+		case TCSANOW:
+			optional_action = TCSETS; break;
+		case TCSADRAIN:
+			optional_action = TCSETSW; break;
+		case TCSAFLUSH:
+			optional_action = TCSETSF; break;
+		default:
+			__ensure(!"Unsupported tcsetattr");
+	}
+
+	if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
+		return r;
+	}
+
+	return 0;
+}
+
+#endif
+
+int sys_tcb_set(void *pointer) {
+	__syscall(SYS_set_fs_base, pointer);
+	return 0;
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
+	__syscall_ret ret = __syscall(SYS_ppoll, fds, nfds, timeout, sigmask);
+	int ret_value = (int)ret.ret;
+
+	if (ret_value == -1)
+		return ret.errno;
+
+	*num_events = ret_value;
+	return 0;
+}
+
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
+	struct timespec ts;
+	ts.tv_sec = timeout / 1000;
+	ts.tv_nsec = (timeout % 1000) * 1000000;
+	return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
+}
+
+int sys_epoll_pwait(int, struct epoll_event *, int,
+					int, const sigset_t *, int *) STUB_ONLY
+
+int sys_epoll_create(int, int *) STUB_ONLY
+
+int sys_epoll_ctl(int, int, int, struct epoll_event *) STUB_ONLY
+
+int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
+		fd_set *except_set, const struct timespec *timeout,
+		const sigset_t *sigmask, int *num_events) {
+	struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
+	if (fds == NULL) {
+		return ENOMEM;
+	}
+
+	for (int i = 0; i < nfds; i++) {
+		struct pollfd *fd = &fds[i];
+
+		if (read_set && FD_ISSET(i, read_set)) {
+			fd->events |= POLLIN;
+		}
+		if (write_set && FD_ISSET(i, write_set)) {
+			fd->events |= POLLOUT;
+		}
+		if (except_set && FD_ISSET(i, except_set)) {
+			fd->events |= POLLPRI;
+		}
+
+		if (!fd->events) {
+			fd->fd = -1;
+			continue;
+		}
+		fd->fd = i;
+	}
+
+	int ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
+	if (ret != 0) {
+		free(fds);
+		return ret;
+	}
+
+	fd_set res_read_set, res_write_set, res_except_set;
+	FD_ZERO(&res_read_set);
+	FD_ZERO(&res_write_set);
+	FD_ZERO(&res_except_set);
+
+	for (int i = 0; i < nfds; i++) {
+		struct pollfd *fd = &fds[i];
+
+		if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0) {
+			FD_SET(i, &res_read_set);
+		}
+		if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0) {
+			FD_SET(i, &res_write_set);
+		}
+		if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) {
+			FD_SET(i, &res_except_set);
+		}
+	}
+
+	free(fds);
+	if (read_set) {
+		*read_set = res_read_set;
+	}
+	if (write_set) {
+		*write_set = res_write_set;
+	}
+	if (except_set) {
+		*except_set = res_except_set;
+	}
+
+	return 0;
+}
+
+#endif
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+	__syscall_ret ret = __syscall(SYS_futex_wait, pointer, expected, time);
+
+	if ((int)ret.ret == -1)
+		return ret.errno;
+
+	return 0;
+}
+
+int sys_futex_wake(int *pointer) {
+	__syscall_ret ret = __syscall(SYS_futex_wake, pointer);
+
+	if ((int)ret.ret == -1)
+		return ret.errno;
+
+	int num_woken = ret.ret;
+
+	__ensure(num_woken >= 0 && num_woken <= 1);
+	return num_woken;
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+int sys_timerfd_create(int, int *) STUB_ONLY
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+	__syscall_ret ret = __syscall(SYS_ioctl, fd, request, arg);
+
+	if ((int)ret.ret == -1)
+		return ret.errno;
+
+	*result = (int)ret.ret;
+	return 0;
+}
+
+int sys_isatty(int fd) {
+	struct winsize ws;
+	int ret;
+
+	if (!sys_ioctl(fd, TIOCGWINSZ, &ws, &ret))
+		return 0;
+
+	return ENOTTY;
+}
+
+int sys_getcwd(char *buffer, size_t size) {
+	__syscall_ret ret = __syscall(SYS_getcwd, buffer, size);
+
+	if ((int)ret.ret == -1)
+		return ret.errno;
+
+	return 0;
+}
+
+#endif
+
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+	__syscall_ret ret = __syscall(SYS_openat, dirfd, path, flags, mode);
+
+	if ((int)ret.ret == -1)
+		return ret.errno;
+
+	*fd = (int)ret.ret;
+	return 0;
+}
+
+int sys_open(const char *path, int flags, mode_t mode, int *fd) {
+	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+int sys_open_dir(const char *path, int *handle) {
+	return sys_openat(AT_FDCWD, path, O_DIRECTORY, 0, handle);
+}
+
+struct ReadDirState {
+	size_t offset;
+	size_t capacity;
+	void *buffer;
+};
+
+static frg::hash_map<int, ReadDirState *, frg::hash<int>, MemoryAllocator> open_dirs{frg::hash<int>{}, getAllocator()};
+
+static ReadDirState *get_dir_state(int fdnum) {
+	ReadDirState *result;
+	if (auto value = open_dirs.get(fdnum)) {
+		result = *value;
+	} else {
+		result = (ReadDirState *)malloc(sizeof(ReadDirState));
+		result->offset = 0;
+		result->capacity = 1024;
+		result->buffer = malloc(result->capacity);
+		open_dirs.insert(fdnum, result);
+	}
+	return result;
+}
+
+int sys_read_entries(int fdnum, void *buffer, size_t max_size, size_t *bytes_read) {
+	ReadDirState *state = get_dir_state(fdnum);
+
+retry:
+	__syscall_ret ret = __syscall(SYS_readdir, fdnum, state->buffer, &state->capacity);
+	if ((int)ret.ret == -1) {
+		if (ret.errno == ENOBUFS) {
+			state->buffer = realloc(state->buffer, state->capacity);
+			goto retry;
+		} else {
+			return ret.errno;
+		}
+	}
+
+	size_t offset = 0;
+	while (offset < max_size) {
+		struct dirent *ent = (struct dirent *)((char *)state->buffer + state->offset);
+		if (ent->d_reclen == 0) {
+			break;
+		}
+
+		if (offset + ent->d_reclen >= max_size) {
+			break;
+		}
+
+		memcpy((char *)buffer + offset, ent, ent->d_reclen);
+		offset += ent->d_reclen;
+		state->offset += ent->d_reclen;
+	}
+
+	*bytes_read = offset;
+	return 0;
+}
+
+#endif
+
+int sys_close(int fd) {
+	__syscall_ret ret = __syscall(SYS_close, fd);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+#ifndef MLIBC_BUILDING_RTLD
+	open_dirs.remove(fd);
+#endif
+	return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+	__syscall_ret ret = __syscall(SYS_seek, fd, offset, whence);
+	off_t ret_value = (off_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*new_offset = ret_value;
+	return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+	__syscall_ret ret = __syscall(SYS_read, fd, buf, count);
+	ssize_t ret_value = (ssize_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*bytes_read = ret_value;
+	return 0;
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+	__syscall_ret ret = __syscall(SYS_write, fd, buf, count);
+	ssize_t ret_value = (ssize_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*bytes_written = ret_value;
+	return 0;
+}
+
+int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length) {
+	__syscall_ret ret = __syscall(SYS_readlinkat, AT_FDCWD, path, data, max_size);
+	ssize_t ret_value = (ssize_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*length = ret_value;
+	return 0;
+}
+
+int sys_link(const char *old_path, const char *new_path) {
+	return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
+}
+
+int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags) {
+	__syscall_ret ret = __syscall(SYS_linkat, olddirfd, old_path, newdirfd, new_path, flags);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_unlinkat(int fd, const char *path, int flags) {
+	__syscall_ret ret = __syscall(SYS_unlinkat, fd, path, flags);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags) {
+	__syscall_ret ret = __syscall(SYS_fchmodat, fd, pathname, mode, flags);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_fchmod(int fd, mode_t mode) {
+	return sys_fchmodat(fd, "", mode, AT_EMPTY_PATH);
+}
+
+int sys_chmod(const char *pathname, mode_t mode) {
+	return sys_fchmodat(AT_FDCWD, pathname, mode, 0);
+}
+
+int sys_rmdir(const char *) STUB_ONLY
+
+#endif
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags,
+			   int fd, off_t offset, void **window) {
+	__syscall_ret ret = __syscall(SYS_mmap, hint, size, (uint64_t)prot << 32 | flags, fd, offset);
+	void *ret_value = (void *)ret.ret;
+	if (ret_value == MAP_FAILED) {
+		return ret.errno;
+	}
+	*window = ret_value;
+	return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size) {
+	__syscall_ret ret = __syscall(SYS_unmmap, pointer, size);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_vm_protect(void *pointer, size_t size, int prot) {
+	__syscall_ret ret = __syscall(SYS_mprotect, pointer, size, prot);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_anon_allocate(size_t size, void **pointer) {
+	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS, -1, 0, pointer);
+}
+
+int sys_anon_free(void *pointer, size_t size) {
+	return sys_vm_unmap(pointer, size);
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+pid_t sys_getpid() {
+	__syscall_ret ret = __syscall(SYS_getpid);
+	return (pid_t)ret.ret;
+}
+
+pid_t sys_getppid() {
+	return 0;
+}
+
+uid_t sys_getuid() {
+	return 0;
+}
+
+uid_t sys_geteuid() {
+	return 0;
+}
+
+gid_t sys_getgid() {
+	return 0;
+}
+
+int sys_setgid(gid_t) {
+	return 0;
+}
+
+int sys_getpgid(pid_t, pid_t *) {
+	return 0;
+}
+
+gid_t sys_getegid() {
+	return 0;
+}
+
+int sys_setpgid(pid_t, pid_t) {
+	return 0;
+}
+
+int sys_ttyname(int, char *, size_t) {
+	return ENOSYS;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+	struct timespec buf;
+	__syscall_ret ret = __syscall(SYS_getclock, clock, &buf);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	*secs = buf.tv_sec;
+	*nanos = buf.tv_nsec;
+	return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+	__syscall_ret ret;
+	switch (fsfdt) {
+		case fsfd_target::fd:
+			ret = __syscall(SYS_stat, fd, "", flags | AT_EMPTY_PATH, statbuf);
+			break;
+		case fsfd_target::path:
+			ret = __syscall(SYS_stat, AT_FDCWD, path, flags, statbuf);
+			break;
+		case fsfd_target::fd_path:
+			ret = __syscall(SYS_stat, fd, path, flags, statbuf);
+			break;
+		default:
+			__ensure(!"sys_stat: Invalid fsfdt");
+			__builtin_unreachable();
+	}
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
+	(void)flags;
+	struct stat buf;
+	if (int r = sys_stat(fsfd_target::fd_path, dirfd, pathname, mode & AT_SYMLINK_FOLLOW, &buf)) {
+		return r;
+	}
+	return 0;
+}
+
+int sys_access(const char *path, int mode) {
+	return sys_faccessat(AT_FDCWD, path, mode, 0);
+}
+
+int sys_pipe(int *fds, int flags) {
+	__syscall_ret ret = __syscall(SYS_pipe, fds, flags);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_chdir(const char *path) {
+	__syscall_ret ret = __syscall(SYS_chdir, path);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_mkdir(const char *path, mode_t mode) {
+	return sys_mkdirat(AT_FDCWD, path, mode);
+}
+
+int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
+	__syscall_ret ret = __syscall(SYS_mkdirat, dirfd, path, mode);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_socket(int domain, int type_and_flags, int proto, int *fd) {
+	__syscall_ret ret = __syscall(SYS_socket, domain, type_and_flags, proto);
+	int ret_value = (int)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*fd = ret_value;
+	return 0;
+}
+
+int sys_socketpair(int domain, int type_and_flags, int proto, int *fds) {
+	__syscall_ret ret = __syscall(SYS_socketpair, domain, type_and_flags, proto, fds);
+	int ret_value = (int)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
+	__syscall_ret ret = __syscall(SYS_bind, fd, addr_ptr, addr_length);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
+	__syscall_ret ret = __syscall(SYS_connect, fd, addr_ptr, addr_length);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length, int flags) {
+	__syscall_ret ret = __syscall(SYS_accept, fd, addr_ptr, addr_length);
+	int ret_value = (int)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*newfd = ret_value;
+
+	if(flags & SOCK_NONBLOCK) {
+		int fcntl_ret = 0;
+		fcntl_helper(*newfd, F_GETFL, &fcntl_ret);
+		fcntl_helper(*newfd, F_SETFL, &fcntl_ret, fcntl_ret | O_NONBLOCK);
+	}
+
+	if(flags & SOCK_CLOEXEC) {
+		int fcntl_ret = 0;
+		fcntl_helper(*newfd, F_GETFD, &fcntl_ret);
+		fcntl_helper(*newfd, F_SETFD, &fcntl_ret, fcntl_ret | FD_CLOEXEC);
+	}
+
+	return 0;
+}
+
+int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) {
+	__syscall_ret ret = __syscall(SYS_getsockopt, fd, layer, number, buffer, size);
+	ssize_t ret_value = (ssize_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) {
+	__syscall_ret ret = __syscall(SYS_setsockopt, fd, layer, number, buffer, size);
+	ssize_t ret_value = (ssize_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_msg_recv(int sockfd, struct msghdr *hdr, int flags, ssize_t *length) {
+	__syscall_ret ret = __syscall(SYS_recvmsg, sockfd, hdr, flags);
+	ssize_t ret_value = (ssize_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*length = ret_value;
+	return 0;
+}
+
+int sys_msg_send(int sockfd, const struct msghdr *hdr, int flags, ssize_t *length) {
+    __syscall_ret ret = __syscall(SYS_sendmsg, sockfd, hdr, flags);
+    ssize_t ret_value = (ssize_t)ret.ret;
+    if (ret_value == -1) {
+        return ret.errno;
+    }
+    *length = ret_value;
+    return 0;
+}
+
+int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+	__syscall_ret ret = __syscall(SYS_getpeername, fd, addr_ptr, &max_addr_length);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	*actual_length = max_addr_length;
+	return 0;
+}
+
+int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+	__syscall_ret ret = __syscall(SYS_getsockname, fd, addr_ptr, &max_addr_length);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	*actual_length = max_addr_length;
+	return 0;
+}
+
+int sys_listen(int fd, int backlog) {
+	__syscall_ret ret = __syscall(SYS_listen, fd, backlog);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_inotify_create(int, int *) {
+	mlibc::infoLogger() << "mlibc: sys_inotify_create() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_fork(pid_t *child) {
+	__syscall_ret ret = __syscall(SYS_fork);
+	pid_t ret_value = (pid_t)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*child = ret_value;
+	return 0;
+}
+
+int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+	__syscall_ret ret = __syscall(SYS_exec, path, argv, envp);
+	return ret.errno;
+}
+
+int sys_fcntl(int fd, int request, va_list args, int *result) {
+	__syscall_ret ret = __syscall(SYS_fcntl, fd, request, va_arg(args, uint64_t));
+	int ret_value = (int)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*result = ret_value;
+	return 0;
+}
+
+int sys_dup(int fd, int flags, int *newfd) {
+	(void)flags;
+	__syscall_ret ret = __syscall(SYS_fcntl, fd, F_DUPFD, 0);
+	int ret_value = (int)ret.ret;
+	if (ret_value == -1) {
+		return ret.errno;
+	}
+	*newfd = ret_value;
+	return 0;
+}
+
+int sys_dup2(int fd, int flags, int newfd) {
+	__syscall_ret ret = __syscall(SYS_dup3, fd, newfd, flags);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_sigprocmask(int, const sigset_t *__restrict, sigset_t *__restrict) {
+	mlibc::infoLogger() << "mlibc: sys_sigprocmask() is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_sigaction(int, const struct sigaction *, struct sigaction *) {
+	mlibc::infoLogger() << "mlibc: sys_sigaction() is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_signalfd_create(sigset_t, int, int *) STUB_ONLY
+
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
+	if (ru != NULL) {
+		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
+		return ENOSYS;
+	}
+again:
+	__syscall_ret ret = __syscall(SYS_waitpid, pid, status, flags);
+	pid_t ret_value = (pid_t)ret.ret;
+	if (ret_value == -1) {
+		if (ret.errno == EINTR) {
+			goto again;
+		}
+		return ret.errno;
+	}
+	*ret_pid = ret_value;
+	return 0;
+}
+
+int sys_getgroups(size_t, gid_t *, int *) {
+	mlibc::infoLogger() << "mlibc: sys_getgroups() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_mount(const char *, const char *, const char *, unsigned long, const void *) STUB_ONLY
+
+int sys_umount2(const char *, int) STUB_ONLY
+
+int sys_gethostname(char *buffer, size_t bufsize) {
+	struct utsname utsname;
+	if (int err = sys_uname(&utsname)) {
+		return err;
+	}
+	if (strlen(utsname.nodename) >= bufsize) {
+		return ENAMETOOLONG;
+	}
+	strncpy(buffer, utsname.nodename, bufsize);
+	return 0;
+}
+
+int sys_sethostname(const char *, size_t) STUB_ONLY
+
+int sys_sleep(time_t *secs, long *nanos) {
+	struct timespec time = {.tv_sec = *secs, .tv_nsec = *nanos};
+	struct timespec rem = {.tv_sec = 0, .tv_nsec = 0};
+	__syscall_ret ret = __syscall(SYS_sleep, &time, &rem);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	*secs = rem.tv_sec;
+	*nanos = rem.tv_nsec;
+	return 0;
+}
+
+int sys_getitimer(int, struct itimerval *) {
+	mlibc::infoLogger() << "mlibc: sys_getitimer() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_setitimer(int, const struct itimerval *, struct itimerval *) {
+	mlibc::infoLogger() << "mlibc: sys_setitimer() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_umask(mode_t mode, mode_t *old) {
+	__syscall_ret ret = __syscall(SYS_umask, mode);
+	*old = (mode_t)ret.ret;
+	return 0;
+}
+
+int sys_uname(struct utsname *buf) {
+	__syscall_ret ret = __syscall(SYS_uname, buf);
+	if ((int)ret.ret == -1) {
+		return ret.errno;
+	}
+	return 0;
+}
+
+int sys_fsync(int) {
+	mlibc::infoLogger() << "sys_fsync is a stub" << frg::endlog;
+	return 0;
+}
+
+#endif
+
+} // namespace mlibc
diff --git mlibc-workdir/sysdeps/lyre/generic/mntent.cpp mlibc-workdir/sysdeps/lyre/generic/mntent.cpp
new file mode 100644
index 0000000..d064af3
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/mntent.cpp
@@ -0,0 +1,97 @@
+#include <errno.h>
+#include <mntent.h>
+#include <stdio.h>
+#include <limits.h>
+#include <string.h>
+#include <bits/ensure.h>
+
+namespace {
+
+char *internal_buf;
+size_t internal_bufsize;
+
+}
+
+#define SENTINEL (char *)&internal_buf
+
+FILE *setmntent(const char *name, const char *mode) {
+	return fopen(name, mode);
+}
+
+struct mntent *getmntent(FILE *f) {
+	static struct mntent mnt;
+	return getmntent_r(f, &mnt, SENTINEL, 0);
+}
+
+int addmntent(FILE *f, const struct mntent *mnt) {
+	if(fseek(f, 0, SEEK_END)) {
+		return 1;
+	}
+	return fprintf(f, "%s\t%s\t%s\t%s\t%d\t%d\n",
+		mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type, mnt->mnt_opts,
+		mnt->mnt_freq, mnt->mnt_passno) < 0;
+}
+
+int endmntent(FILE *f) {
+	if(f) {
+		fclose(f);
+	}
+	return 1;
+}
+
+char *hasmntopt(const struct mntent *mnt, const char *opt) {
+	return strstr(mnt->mnt_opts, opt);
+}
+
+/* Adapted from musl */
+struct mntent *getmntent_r(FILE *f, struct mntent *mnt, char *linebuf, int buflen) {
+	int n[8];
+	bool use_internal = (linebuf == SENTINEL);
+	int len;
+	size_t i;
+
+	mnt->mnt_freq = 0;
+	mnt->mnt_passno = 0;
+
+	do {
+		if(use_internal) {
+			getline(&internal_buf, &internal_bufsize, f);
+			linebuf = internal_buf;
+		} else {
+			fgets(linebuf, buflen, f);
+		}
+		if(feof(f) || ferror(f)) {
+			return 0;
+		}
+		if(!strchr(linebuf, '\n')) {
+			fscanf(f, "%*[^\n]%*[\n]");
+			errno = ERANGE;
+			return 0;
+		}
+
+		len = strlen(linebuf);
+		if(len > INT_MAX) {
+			continue;
+		}
+
+		for(i = 0; i < sizeof n / sizeof *n; i++) {
+			n[i] = len;
+		}
+
+		sscanf(linebuf, " %n%*s%n %n%*s%n %n%*s%n %n%*s%n %d %d",
+			n, n + 1, n + 2, n + 3, n + 4, n + 5, n + 6, n + 7,
+			&mnt->mnt_freq, &mnt->mnt_passno);
+	} while(linebuf[n[0]] == '#' || n[1] == len);
+
+	linebuf[n[1]] = 0;
+	linebuf[n[3]] = 0;
+	linebuf[n[5]] = 0;
+	linebuf[n[7]] = 0;
+
+	mnt->mnt_fsname = linebuf + n[0];
+	mnt->mnt_dir = linebuf + n[2];
+	mnt->mnt_type = linebuf + n[4];
+	mnt->mnt_opts = linebuf + n[6];
+
+	return mnt;
+}
diff --git mlibc-workdir/sysdeps/lyre/generic/mount.cpp mlibc-workdir/sysdeps/lyre/generic/mount.cpp
new file mode 100644
index 0000000..f10254d
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/mount.cpp
@@ -0,0 +1,16 @@
+#include <errno.h>
+#include <sys/mount.h>
+#include <bits/ensure.h>
+
+int mount(const char *source, const char *target,
+		const char *fstype, unsigned long flags, const void *data) {
+	return 0;
+}
+
+int umount(const char *target) {
+	return umount2(target, 0);
+}
+
+int umount2(const char *target, int flags) {
+	return 0;
+}
diff --git mlibc-workdir/sysdeps/lyre/generic/reboot.cpp mlibc-workdir/sysdeps/lyre/generic/reboot.cpp
new file mode 100644
index 0000000..7c86ffd
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/reboot.cpp
@@ -0,0 +1,7 @@
+#include <errno.h>
+#include <sys/reboot.h>
+#include <bits/ensure.h>
+
+int reboot(int what) {
+	return 0;
+}
diff --git mlibc-workdir/sysdeps/lyre/generic/thread.S mlibc-workdir/sysdeps/lyre/generic/thread.S
new file mode 100644
index 0000000..47ab6a9
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/thread.S
@@ -0,0 +1,9 @@
+.section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_thread_trampoline
+
+.section .note.GNU-stack,"",%progbits
diff --git mlibc-workdir/sysdeps/lyre/generic/thread.cpp mlibc-workdir/sysdeps/lyre/generic/thread.cpp
new file mode 100644
index 0000000..5186e1f
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/thread.cpp
@@ -0,0 +1,58 @@
+#include <sys/mman.h>
+#include <mlibc/debug.hpp>
+#include <errno.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <bits/ensure.h>
+#include <mlibc/tcb.hpp>
+
+extern "C" void __mlibc_thread_trampoline(void *(*fn)(void *), Tcb *tcb, void *arg) {
+	if (mlibc::sys_tcb_set(tcb)) {
+		__ensure(!"failed to set tcb for new thread");
+	}
+
+	while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0) {
+		mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);
+	}
+
+	tcb->invokeThreadFunc(reinterpret_cast<void *>(fn), arg);
+
+	__atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&tcb->didExit);
+
+	mlibc::sys_thread_exit();
+}
+
+#define DEFAULT_STACK 0x400000
+
+namespace mlibc {
+	int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size, void **stack_base) {
+		// TODO guard
+
+		mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+
+		*guard_size = 0;
+
+		*stack_size = *stack_size ? *stack_size : DEFAULT_STACK;
+
+		if (!*stack) {
+			*stack_base = mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+			if (*stack_base == MAP_FAILED) {
+				return errno;
+			}
+		} else {
+			*stack_base = *stack;
+		}
+		
+		*stack = (void *)((char *)*stack_base + *stack_size);
+
+		void **stack_it = (void **)*stack;
+
+		*--stack_it = arg;
+		*--stack_it = tcb;
+		*--stack_it = entry;
+
+		*stack = (void *)stack_it;
+
+		return 0;
+	}
+}
diff --git mlibc-workdir/sysdeps/lyre/generic/utmpx.c mlibc-workdir/sysdeps/lyre/generic/utmpx.c
new file mode 100644
index 0000000..61bd6e7
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/generic/utmpx.c
@@ -0,0 +1,76 @@
+#include <bits/ensure.h>
+#include <stddef.h>
+#include <errno.h>
+#include <utmpx.h>
+#include <stdio.h>
+#include <time.h>
+#include <paths.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+int utmpx_file = -1;
+
+void updwtmpx(const char *, const struct utmpx *) {
+	// Empty as musl does
+}
+
+void endutxent(void) {
+	if (utmpx_file >= 0) {
+		close(utmpx_file);
+	}
+}
+
+void setutxent(void) {
+	if (utmpx_file < 0) {
+		utmpx_file = open(UTMPX_FILE, O_RDWR | O_CREAT, 0755);
+	} else {
+		lseek(utmpx_file, 0, SEEK_SET);
+	}
+}
+
+static struct utmpx returned;
+
+struct utmpx *getutxent(void) {
+	if (utmpx_file < 0) {
+		setutxent();
+		if (utmpx_file < 0) {
+			return NULL;
+		}
+	}
+
+	if (read(utmpx_file, &returned, sizeof(struct utmpx)) != sizeof(struct utmpx)) {
+		return NULL;
+	}
+
+	return &returned;
+}
+
+struct utmpx *pututxline(const struct utmpx *added) {
+	if (utmpx_file < 0) {
+		setutxent();
+		if (utmpx_file < 0) {
+			return NULL;
+		}
+	}
+
+	lseek(utmpx_file, 0, SEEK_END);
+	if (write(utmpx_file, added, sizeof(struct utmpx)) != sizeof(struct utmpx)) {
+		return NULL;
+	}
+
+	return (struct utmpx *)added;
+}
+
+int utmpxname(const char *path) {
+	if (utmpx_file > 0) {
+		close(utmpx_file);
+	}
+
+	utmpx_file = open(path, O_RDWR | O_CREAT, 0755);
+	if (utmpx_file > 0) {
+		lseek(utmpx_file, 0, SEEK_END);
+		return 1;
+	} else {
+		return 0;
+	}
+}
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/access.h mlibc-workdir/sysdeps/lyre/include/abi-bits/access.h
new file mode 120000
index 0000000..cb83931
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/auxv.h mlibc-workdir/sysdeps/lyre/include/abi-bits/auxv.h
new file mode 120000
index 0000000..c43f878
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/blkcnt_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/blkcnt_t.h
new file mode 120000
index 0000000..0b0ec27
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/blksize_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/blksize_t.h
new file mode 120000
index 0000000..7dc8d7c
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/clockid_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/clockid_t.h
new file mode 120000
index 0000000..6a42da5
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/dev_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/dev_t.h
new file mode 120000
index 0000000..bca881e
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/errno.h mlibc-workdir/sysdeps/lyre/include/abi-bits/errno.h
new file mode 120000
index 0000000..6e507de
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/fcntl.h mlibc-workdir/sysdeps/lyre/include/abi-bits/fcntl.h
new file mode 120000
index 0000000..463e2c9
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/fsblkcnt_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/fsblkcnt_t.h
new file mode 120000
index 0000000..898dfb2
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/fsblkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsblkcnt_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/fsfilcnt_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/fsfilcnt_t.h
new file mode 120000
index 0000000..791755c
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/fsfilcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsfilcnt_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/gid_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/gid_t.h
new file mode 120000
index 0000000..abce6d6
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/gid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/in.h mlibc-workdir/sysdeps/lyre/include/abi-bits/in.h
new file mode 120000
index 0000000..418d1d5
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/ino_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/ino_t.h
new file mode 120000
index 0000000..4c20aca
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/ioctls.h mlibc-workdir/sysdeps/lyre/include/abi-bits/ioctls.h
new file mode 120000
index 0000000..595106b
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/ioctls.h
@@ -0,0 +1 @@
+../../../../abis/linux/ioctls.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/ipc.h mlibc-workdir/sysdeps/lyre/include/abi-bits/ipc.h
new file mode 120000
index 0000000..2c7ffc4
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/ipc.h
@@ -0,0 +1 @@
+../../../../abis/linux/ipc.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/limits.h mlibc-workdir/sysdeps/lyre/include/abi-bits/limits.h
new file mode 120000
index 0000000..6c88db2
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/mode_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/mode_t.h
new file mode 120000
index 0000000..5d78fdf
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/mqueue.h mlibc-workdir/sysdeps/lyre/include/abi-bits/mqueue.h
new file mode 120000
index 0000000..fa87b07
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/mqueue.h
@@ -0,0 +1 @@
+../../../../abis/linux/mqueue.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/msg.h mlibc-workdir/sysdeps/lyre/include/abi-bits/msg.h
new file mode 120000
index 0000000..f402b49
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/msg.h
@@ -0,0 +1 @@
+../../../../abis/linux/msg.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/nlink_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/nlink_t.h
new file mode 120000
index 0000000..bb3b625
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/packet.h mlibc-workdir/sysdeps/lyre/include/abi-bits/packet.h
new file mode 120000
index 0000000..998ef1a
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/pid_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/pid_t.h
new file mode 120000
index 0000000..baa90f6
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/poll.h mlibc-workdir/sysdeps/lyre/include/abi-bits/poll.h
new file mode 120000
index 0000000..8ea6a0a
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/reboot.h mlibc-workdir/sysdeps/lyre/include/abi-bits/reboot.h
new file mode 120000
index 0000000..4a770ae
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/lyre/reboot.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/resource.h mlibc-workdir/sysdeps/lyre/include/abi-bits/resource.h
new file mode 120000
index 0000000..88d7402
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/rlim_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/rlim_t.h
new file mode 120000
index 0000000..e92eb5f
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/rlim_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/rlim_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/seek-whence.h mlibc-workdir/sysdeps/lyre/include/abi-bits/seek-whence.h
new file mode 120000
index 0000000..df7bccf
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/shm.h mlibc-workdir/sysdeps/lyre/include/abi-bits/shm.h
new file mode 120000
index 0000000..067d8c4
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/sigevent.h mlibc-workdir/sysdeps/lyre/include/abi-bits/sigevent.h
new file mode 120000
index 0000000..bacb0b2
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/sigevent.h
@@ -0,0 +1 @@
+../../../../abis/lyre/sigevent.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/signal.h mlibc-workdir/sysdeps/lyre/include/abi-bits/signal.h
new file mode 120000
index 0000000..477a36b
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/lyre/signal.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/sigval.h mlibc-workdir/sysdeps/lyre/include/abi-bits/sigval.h
new file mode 120000
index 0000000..ccd43a5
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/sigval.h
@@ -0,0 +1 @@
+../../../../abis/linux/sigval.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/socket.h mlibc-workdir/sysdeps/lyre/include/abi-bits/socket.h
new file mode 120000
index 0000000..f1dc016
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/socklen_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/socklen_t.h
new file mode 120000
index 0000000..41f3b11
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/socklen_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/socklen_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/stat.h mlibc-workdir/sysdeps/lyre/include/abi-bits/stat.h
new file mode 120000
index 0000000..1f63b41
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/statvfs.h mlibc-workdir/sysdeps/lyre/include/abi-bits/statvfs.h
new file mode 120000
index 0000000..d0bdd40
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/statvfs.h
@@ -0,0 +1 @@
+../../../../abis/lyre/statvfs.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/suseconds_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/suseconds_t.h
new file mode 120000
index 0000000..9ed6597
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/suseconds_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/suseconds_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/termios.h mlibc-workdir/sysdeps/lyre/include/abi-bits/termios.h
new file mode 120000
index 0000000..ee8f0b0
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/time.h mlibc-workdir/sysdeps/lyre/include/abi-bits/time.h
new file mode 120000
index 0000000..2a02625
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/uid_t.h mlibc-workdir/sysdeps/lyre/include/abi-bits/uid_t.h
new file mode 120000
index 0000000..b306777
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/utsname.h mlibc-workdir/sysdeps/lyre/include/abi-bits/utsname.h
new file mode 120000
index 0000000..b285754
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/vm-flags.h mlibc-workdir/sysdeps/lyre/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..bbe258c
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/abi-bits/wait.h mlibc-workdir/sysdeps/lyre/include/abi-bits/wait.h
new file mode 120000
index 0000000..feb2840
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git mlibc-workdir/sysdeps/lyre/include/asm/ioctl.h mlibc-workdir/sysdeps/lyre/include/asm/ioctl.h
new file mode 100644
index 0000000..8cbb364
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/asm/ioctl.h
@@ -0,0 +1,105 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _ASM_GENERIC_IOCTL_H
+#define _ASM_GENERIC_IOCTL_H
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+ * size of the parameter structure in the lower 14 bits of the
+ * upper 16 bits.
+ * Encoding the size of the parameter structure in the ioctl request
+ * is useful for catching programs compiled with old versions
+ * and to avoid overwriting user space outside the user buffer area.
+ * The highest 2 bits are reserved for indicating the ``access mode''.
+ * NOTE: This limits the max parameter size to 16kB -1 !
+ */
+
+/*
+ * The following is for compatibility across the various Linux
+ * platforms.  The generic ioctl numbering scheme doesn't really enforce
+ * a type field.  De facto, however, the top 8 bits of the lower 16
+ * bits are indeed used as a type field, so we might just as well make
+ * this explicit here.  Please be sure to use the decoding macros
+ * below from now on.
+ */
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+
+/*
+ * Let any architecture override either of the following before
+ * including this file.
+ */
+
+#ifndef _IOC_SIZEBITS
+# define _IOC_SIZEBITS	14
+#endif
+
+#ifndef _IOC_DIRBITS
+# define _IOC_DIRBITS	2
+#endif
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits, which any architecture can choose to override
+ * before including this file.
+ *
+ * NOTE: _IOC_WRITE means userland is writing and kernel is
+ * reading. _IOC_READ means userland is reading and kernel is writing.
+ */
+
+#ifndef _IOC_NONE
+# define _IOC_NONE	0U
+#endif
+
+#ifndef _IOC_WRITE
+# define _IOC_WRITE	1U
+#endif
+
+#ifndef _IOC_READ
+# define _IOC_READ	2U
+#endif
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+#define _IOC_TYPECHECK(t) (sizeof(t))
+
+/*
+ * Used to create numbers.
+ *
+ * NOTE: _IOW means userland is writing and kernel is reading. _IOR
+ * means userland is reading and kernel is writing.
+ */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_GENERIC_IOCTL_H */
diff --git mlibc-workdir/sysdeps/lyre/include/asm/ioctls.h mlibc-workdir/sysdeps/lyre/include/asm/ioctls.h
new file mode 100644
index 0000000..bdbba9b
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/asm/ioctls.h
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef __ASM_GENERIC_IOCTLS_H
+#define __ASM_GENERIC_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+/*
+ * These are the most common definitions for tty ioctl numbers.
+ * Most of them do not use the recommended _IOC(), but there is
+ * probably some source code out there hardcoding the number,
+ * so we might as well use them for all new platforms.
+ *
+ * The architectures that use different values here typically
+ * try to be compatible with some Unix variants for the same
+ * architecture.
+ */
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TCGETS2		_IOR('T', 0x2A, struct termios2)
+#define TCSETS2		_IOW('T', 0x2B, struct termios2)
+#define TCSETSW2	_IOW('T', 0x2C, struct termios2)
+#define TCSETSF2	_IOW('T', 0x2D, struct termios2)
+#define TIOCGRS485	0x542E
+#ifndef TIOCSRS485
+#define TIOCSRS485	0x542F
+#endif
+#define TIOCGPTN	_IOR('T', 0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T', 0x31, int)  /* Lock/unlock Pty */
+#define TIOCGDEV	_IOR('T', 0x32, unsigned int) /* Get primary device node of /dev/console */
+#define TCGETX		0x5432 /* SYS5 TCGETX compatibility */
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+#define TIOCSIG		_IOW('T', 0x36, int)  /* pty: generate signal */
+#define TIOCVHANGUP	0x5437
+#define TIOCGPKT	_IOR('T', 0x38, int) /* Get packet mode state */
+#define TIOCGPTLCK	_IOR('T', 0x39, int) /* Get Pty lock state */
+#define TIOCGEXCL	_IOR('T', 0x40, int) /* Get exclusive mode state */
+#define TIOCGPTPEER	_IO('T', 0x41) /* Safely open the slave */
+#define TIOCGISO7816	_IOR('T', 0x42, struct serial_iso7816)
+#define TIOCSISO7816	_IOWR('T', 0x43, struct serial_iso7816)
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port __inline__ interrupt counts */
+
+/*
+ * Some arches already define FIOQSIZE due to a historical
+ * conflict with a Hayes modem-specific ioctl value.
+ */
+#ifndef FIOQSIZE
+# define FIOQSIZE	0x5460
+#endif
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+#define TIOCPKT_IOCTL		64
+
+#define TIOCSER_TEMT	0x01	/* Transmitter physically empty */
+
+#endif /* __ASM_GENERIC_IOCTLS_H */
diff --git mlibc-workdir/sysdeps/lyre/include/linux/fb.h mlibc-workdir/sysdeps/lyre/include/linux/fb.h
new file mode 100644
index 0000000..d5e6d88
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/linux/fb.h
@@ -0,0 +1,400 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <stddef.h>
+#include <asm/ioctl.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, uint32_t)
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+#define FB_TYPE_FOURCC			5	/* Type identified by a V4L2 FOURCC */
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+#define FB_VISUAL_FOURCC		6	/* Visual identified by a V4L2 FOURCC */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/
+
+#define FB_CAP_FOURCC		1	/* Device supports FOURCC-based formats */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	uint32_t smem_len;			/* Length of frame buffer mem */
+	uint32_t type;			/* see FB_TYPE_*		*/
+	uint32_t type_aux;			/* Interleave for interleaved Planes */
+	uint32_t visual;			/* see FB_VISUAL_*		*/ 
+	uint16_t xpanstep;			/* zero if no hardware panning  */
+	uint16_t ypanstep;			/* zero if no hardware panning  */
+	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
+	uint32_t line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
+	uint32_t accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	uint16_t capabilities;		/* see FB_CAP_*			*/
+	uint16_t reserved[2];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the palette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	uint32_t offset;			/* beginning of bitfield	*/
+	uint32_t length;			/* length of bitfield		*/
+	uint32_t msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+#define FB_ACTIVATE_KD_TEXT   512       /* for KDSET vt ioctl */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	uint32_t xres;			/* visible resolution		*/
+	uint32_t yres;
+	uint32_t xres_virtual;		/* virtual resolution		*/
+	uint32_t yres_virtual;
+	uint32_t xoffset;			/* offset from virtual to visible */
+	uint32_t yoffset;			/* resolution			*/
+
+	uint32_t bits_per_pixel;		/* guess what			*/
+	uint32_t grayscale;		/* 0 = color, 1 = grayscale,	*/
+					/* >1 = FOURCC			*/
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	uint32_t nonstd;			/* != 0 Non standard pixel format */
+
+	uint32_t activate;			/* see FB_ACTIVATE_*		*/
+
+	uint32_t height;			/* height of picture in mm    */
+	uint32_t width;			/* width of picture in mm     */
+
+	uint32_t accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
+	uint32_t left_margin;		/* time from sync to picture	*/
+	uint32_t right_margin;		/* time from picture to sync	*/
+	uint32_t upper_margin;		/* time from sync to picture	*/
+	uint32_t lower_margin;
+	uint32_t hsync_len;		/* length of horizontal sync	*/
+	uint32_t vsync_len;		/* length of vertical sync	*/
+	uint32_t sync;			/* see FB_SYNC_*		*/
+	uint32_t vmode;			/* see FB_VMODE_*		*/
+	uint32_t rotate;			/* angle we rotate counter clockwise */
+	uint32_t colorspace;		/* colorspace for FOURCC-based modes */
+	uint32_t reserved[4];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	uint32_t start;			/* First entry	*/
+	uint32_t len;			/* Number of entries */
+	uint16_t *red;			/* Red values	*/
+	uint16_t *green;
+	uint16_t *blue;
+	uint16_t *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	uint32_t console;
+	uint32_t framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	uint32_t flags;			/* FB_VBLANK flags */
+	uint32_t count;			/* counter of retraces since boot */
+	uint32_t vcount;			/* current scanline position */
+	uint32_t hcount;			/* current scandot position */
+	uint32_t reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	uint32_t dx;
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t sx;
+	uint32_t sy;
+};
+
+struct fb_fillrect {
+	uint32_t dx;	/* screen-relative */
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t color;
+	uint32_t rop;
+};
+
+struct fb_image {
+	uint32_t dx;		/* Where to place image */
+	uint32_t dy;
+	uint32_t width;		/* Size of image */
+	uint32_t height;
+	uint32_t fg_color;		/* Only used when a mono bitmap */
+	uint32_t bg_color;
+	uint8_t  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	uint16_t x, y;
+};
+
+struct fb_cursor {
+	uint16_t set;		/* what to set */
+	uint16_t enable;		/* cursor on/off */
+	uint16_t rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+
+
+#endif /* _LINUX_FB_H */
diff --git mlibc-workdir/sysdeps/lyre/include/lyre/sockios.h mlibc-workdir/sysdeps/lyre/include/lyre/sockios.h
new file mode 100644
index 0000000..9c5a318
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/lyre/sockios.h
@@ -0,0 +1,25 @@
+#ifndef _LYRE__SOCKIOS_H
+#define _LYRE__SOCKIOS_H
+
+#include <asm/ioctls.h>
+
+#define SIOCINQ FIONREAD
+#define SIOCOUTQ TIOCOUTQ
+
+#define SIOCGIFNAME	0x8910 /* get interface name */
+#define SIOCGIFFLAGS 0x8911 /* get flags */
+#define SIOCSIFFLAGS 0x8912 /* set flags */
+#define SIOCGIFADDR	0x8913 /* get interface ip */
+#define SIOCSIFADDR	0x8914 /* set interface ip */
+#define SIOCGIFNETMASK 0x8915 /* set netmask */
+#define SIOCSIFNETMASK 0x8916 /* get netmask */
+#define SIOCGIFMTU 0x8917 /* get mtu */
+#define SIOCSIFMTU 0x8918 /* set mtu */
+#define SIOCSIFNAME	0x8919 /* set interface name */
+#define	SIOCSIFHWADDR 0x891a /* set mac address */
+#define SIOCGIFHWADDR 0x891b /* get mac address */
+#define SIOCGIFINDEX 0x891c /* get interface index */
+#define SIOCGIFGATEWAY 0x891d /* get gateway ip */
+#define SIOCSIFGATEWAY 0x891e /* set gateway ip */
+
+#endif
diff --git mlibc-workdir/sysdeps/lyre/include/lyre/syscall.h mlibc-workdir/sysdeps/lyre/include/lyre/syscall.h
new file mode 100644
index 0000000..531b869
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/lyre/syscall.h
@@ -0,0 +1,113 @@
+#ifndef _LYRE__SYSCALL_H
+#define _LYRE__SYSCALL_H
+
+#include <stdint.h>
+
+#define SYS_debug 0
+#define SYS_mmap 1
+#define SYS_openat 2
+#define SYS_close 3
+#define SYS_read 4
+#define SYS_write 5
+#define SYS_seek 6
+#define SYS_set_fs_base 7
+#define SYS_set_gs_base 8
+#define SYS_stat 9
+#define SYS_fcntl 10
+#define SYS_dup3 11
+#define SYS_ioctl 12
+#define SYS_fork 13
+#define SYS_exec 14
+#define SYS_getpid 15
+#define SYS_waitpid 16
+#define SYS_exit 17
+#define SYS_getcwd 18
+#define SYS_chdir 19
+#define SYS_unmmap 20
+#define SYS_pipe 21
+#define SYS_readlinkat 22
+#define SYS_linkat 23
+#define SYS_unlinkat 24
+#define SYS_readdir 25
+#define SYS_uname 26
+#define SYS_futex_wait 27
+#define SYS_futex_wake 28
+#define SYS_mkdirat 29
+#define SYS_fchmodat 30
+#define SYS_sleep 31
+#define SYS_ppoll 32
+#define SYS_umask 33
+#define SYS_mprotect 34
+#define SYS_getclock 35
+#define SYS_socket 36
+#define SYS_bind 37
+#define SYS_connect 38
+#define SYS_listen 39
+#define SYS_accept 40
+#define SYS_getpeername 41
+#define SYS_recvmsg 42
+#define SYS_new_thread 43
+#define SYS_exit_thread 44
+#define SYS_sendmsg 45
+#define SYS_socketpair 46
+#define SYS_getsockopt 47
+#define SYS_setsockopt 48
+#define SYS_getsockname 49
+
+struct __syscall_ret {
+	uint64_t ret;
+	uint64_t errno;
+};
+
+#define __SYSCALL_EXPAND(...) \
+	struct __syscall_ret ret; \
+	asm volatile ( \
+		"mov %%rsp, %%r10\n\t" \
+		"lea 1f(%%rip), %%r11\n\t" \
+		"sysenter\n\t" \
+		"1:" \
+		: "=a"(ret.ret), "=b"(ret.errno) __VA_ARGS__ \
+		"r10", "r11", "memory" \
+	); \
+	return ret
+
+static inline struct __syscall_ret __syscall5(int number, uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e) {
+    register uint64_t r8 asm("%r8") = d;
+    register uint64_t r9 asm("%r9") = e;
+    __SYSCALL_EXPAND(, "+d"(b), "+c"(c) : "D"(number), "S"(a), "r"(r8), "r"(r9) :);
+}
+
+static inline struct __syscall_ret __syscall4(int number, uint64_t a, uint64_t b, uint64_t c, uint64_t d) {
+    register uint64_t r8 asm("%r8") = d;
+    __SYSCALL_EXPAND(, "+d"(b), "+c"(c) : "D"(number), "S"(a), "r"(r8) :);
+}
+
+static inline struct __syscall_ret __syscall3(int number, uint64_t a, uint64_t b, uint64_t c) {
+    __SYSCALL_EXPAND(, "+d"(b), "+c"(c) : "D"(number), "S"(a) :);
+}
+
+static inline struct __syscall_ret __syscall2(int number, uint64_t a, uint64_t b) {
+    __SYSCALL_EXPAND(, "+d"(b) : "D"(number), "S"(a) : "rcx", );
+}
+
+static inline struct __syscall_ret __syscall1(int number, uint64_t a) {
+    __SYSCALL_EXPAND( : "D"(number), "S"(a) : "rcx", "rdx", );
+}
+
+static inline struct __syscall_ret __syscall0(int number) {
+    __SYSCALL_EXPAND( : "D"(number) : "rcx", "rdx", );
+}
+
+#define __SYSCALL_NARGS_SEQ(_0,_1,_2,_3,_4,_5,_6,_7,N,...) N
+#define __SYSCALL_NARGS(...) __SYSCALL_NARGS_SEQ(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)
+
+#define __SYSCALL_CONCAT1(X, Y) X##Y
+#define __SYSCALL_CONCAT(X, Y) __SYSCALL_CONCAT1(X, Y)
+
+#define __syscall(...) ({ \
+    struct __syscall_ret (*__SYSCALL_f)(int, ...); \
+    __SYSCALL_f = (struct __syscall_ret (*)(int, ...))__SYSCALL_CONCAT(__syscall, __SYSCALL_NARGS(__VA_ARGS__)); \
+    __SYSCALL_f(__VA_ARGS__); \
+})
+
+#endif
diff --git mlibc-workdir/sysdeps/lyre/include/mntent.h mlibc-workdir/sysdeps/lyre/include/mntent.h
new file mode 100644
index 0000000..42f0184
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/mntent.h
@@ -0,0 +1,50 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#include <stdio.h>
+
+/* TODO: Refer to _PATH_MOUNTED */
+#define MOUNTED "/etc/mtab"
+
+/* Generic mount options */
+#define MNTOPT_DEFAULTS "defaults"		/* Use all default options. */
+#define MNTOPT_RO       "ro"			/* Read only. */
+#define MNTOPT_RW       "rw"			/* Read/write. */
+#define MNTOPT_SUID     "suid"			/* Set uid allowed. */
+#define MNTOPT_NOSUID   "nosuid"		/* No set uid allowed. */
+#define MNTOPT_NOAUTO   "noauto"		/* Do not auto mount. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mntent {
+	char *mnt_fsname;
+	char *mnt_dir;
+	char *mnt_type;
+	char *mnt_opts;
+	int mnt_freq;
+	int mnt_passno;
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+FILE *setmntent(const char *, const char *);
+
+struct mntent *getmntent(FILE *);
+
+int addmntent(FILE *, const struct mntent *);
+
+int endmntent(FILE *);
+
+char *hasmntopt(const struct mntent *, const char *);
+
+struct mntent *getmntent_r(FILE *, struct mntent *,  char *, int);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MNTENT_H */
diff --git mlibc-workdir/sysdeps/lyre/include/sys/mount.h mlibc-workdir/sysdeps/lyre/include/sys/mount.h
new file mode 100644
index 0000000..844abdb
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/sys/mount.h
@@ -0,0 +1,54 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MS_RDONLY 1
+#define MS_NOSUID 2
+#define MS_NODEV 4
+#define MS_NOEXEC 8
+#define MS_SYNCHRONOUS 16
+#define MS_REMOUNT 32
+#define MS_MANDLOCK 64
+#define MS_DIRSYNC 128
+#define MS_NOSYMFOLLOW 256
+#define MS_NOATIME 1024
+#define MS_NODIRATIME 2048
+#define MS_BIND 4096
+#define MS_MOVE 8192
+#define MS_REC 16384
+#define MS_SILENT 32768
+#define MS_POSIXACL (1 << 16)
+#define MS_UNBINDABLE (1 << 17)
+#define MS_PRIVATE (1 << 18)
+#define MS_SLAVE (1 << 19)
+#define MS_SHARED (1 << 20)
+#define MS_RELATIME (1 << 21)
+#define MS_KERNMOUNT (1 << 22)
+#define MS_I_VERSION (1 << 23)
+#define MS_STRICTATIME (1 << 24)
+#define MS_LAZYTIME (1 << 25)
+#define MS_NOREMOTELOCK (1 << 27)
+#define MS_NOSEC (1 << 28)
+#define MS_BORN (1 << 29)
+#define MS_ACTIVE (1 << 30)
+#define MS_NOUSER (1 << 31)
+
+#define MNT_FORCE 1
+
+#ifndef __MLIBC_ABI_ONLY
+
+int mount(const char *source, const char *target,
+		const char *fstype, unsigned long flags, const void *data);
+int umount(const char *target);
+int umount2(const char *target, int flags);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_MOUNT_H */
diff --git mlibc-workdir/sysdeps/lyre/include/sys/reboot.h mlibc-workdir/sysdeps/lyre/include/sys/reboot.h
new file mode 100644
index 0000000..0628ae4
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/sys/reboot.h
@@ -0,0 +1,20 @@
+#ifndef MLIBC_SYS_REBOOT_H
+#define MLIBC_SYS_REBOOT_H
+
+#include <abi-bits/reboot.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __MLIBC_ABI_ONLY
+
+int reboot(int arg);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MLIBC_SYS_REBOOT_H */
diff --git mlibc-workdir/sysdeps/lyre/include/sys/sysmacros.h mlibc-workdir/sysdeps/lyre/include/sys/sysmacros.h
new file mode 100644
index 0000000..9682d01
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/sys/sysmacros.h
@@ -0,0 +1,33 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static unsigned int __mlibc_dev_major(
+		unsigned long long int __dev) {
+  return ((__dev >> 8) & 0xfff) | ((unsigned int)(__dev >> 32) & ~0xfff);
+}
+
+static unsigned int __mlibc_dev_minor(
+		unsigned long long int __dev) {
+  return (__dev & 0xff) | ((unsigned int)(__dev >> 12) & ~0xff);
+}
+
+static unsigned long long int __mlibc_dev_makedev(
+		unsigned int __major, unsigned int __minor) {
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+	  | (((unsigned long long int)(__minor & ~0xff)) << 12)
+	  | (((unsigned long long int)(__major & ~0xfff)) << 32));
+}
+
+#define major(dev) __mlibc_dev_major(dev)
+#define minor(dev) __mlibc_dev_minor(dev)
+#define makedev(major, minor) __mlibc_dev_makedev(major, minor)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_SYSMACROS_H */
diff --git mlibc-workdir/sysdeps/lyre/include/utmpx.h mlibc-workdir/sysdeps/lyre/include/utmpx.h
new file mode 100644
index 0000000..d479f6d
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/include/utmpx.h
@@ -0,0 +1,63 @@
+
+#ifndef  _UTMPX_H
+#define  _UTMPX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <abi-bits/pid_t.h>
+#include <bits/posix/timeval.h>
+
+#define UTMPX_FILE "/var/run/utmp"
+#define WTMPX_FILE "/var/run/wtmp"
+
+/* Struct definition taken from musl */
+struct utmpx {
+	short ut_type;
+	short __ut_pad1;
+	pid_t ut_pid;
+	char ut_line[32];
+	char ut_id[4];
+	char ut_user[32];
+	char ut_host[256];
+	struct {
+		short __e_termination;
+		short __e_exit;
+	} ut_exit;
+	int ut_session, __ut_pad2;
+	struct timeval ut_tv;
+	unsigned ut_addr_v6[4];
+	char __unused[20];
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+void updwtmpx(const char *, const struct utmpx *);
+int utmpxname(const char *);
+struct utmpx *pututxline(const struct utmpx *);
+struct utmpx *getutxent(void);
+void setutxent(void);
+void endutxent(void);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#define EMPTY           0
+#define RUN_LVL         1
+#define BOOT_TIME       2
+#define NEW_TIME        3
+#define OLD_TIME        4
+#define INIT_PROCESS    5
+#define LOGIN_PROCESS   6
+#define USER_PROCESS    7
+#define DEAD_PROCESS    8
+
+#define __UT_HOSTSIZE 256
+#define __UT_NAMESIZE 32
+#define __UT_LINESIZE 32
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UTMPX_H */
diff --git mlibc-workdir/sysdeps/lyre/meson.build mlibc-workdir/sysdeps/lyre/meson.build
new file mode 100644
index 0000000..1862477
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/meson.build
@@ -0,0 +1,129 @@
+sysdep_supported_options = {
+	'posix': true,
+	'linux': false,
+	'glibc': true,
+	'bsd': true,
+}
+
+rtld_sources += files(
+	'generic/generic.cpp'
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp',
+	'generic/mntent.cpp',
+	'generic/mount.cpp',
+	'generic/reboot.cpp',
+	'generic/thread.cpp',
+	'generic/thread.S',
+	'generic/utmpx.c',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/packet.h',
+		'include/abi-bits/clockid_t.h',
+		'include/abi-bits/ipc.h',
+		'include/abi-bits/shm.h',
+		'include/abi-bits/mqueue.h',
+		'include/abi-bits/suseconds_t.h',
+		'include/abi-bits/fsfilcnt_t.h',
+		'include/abi-bits/fsblkcnt_t.h',
+		'include/abi-bits/socklen_t.h',
+		'include/abi-bits/statvfs.h',
+		'include/abi-bits/ioctls.h',
+		'include/abi-bits/msg.h',
+		'include/abi-bits/rlim_t.h',
+		'include/abi-bits/sigval.h',
+		'include/abi-bits/sigevent.h',
+		subdir: 'abi-bits',
+		follow_symlinks: true
+	)
+
+	install_headers(
+		'include/asm/ioctl.h',
+		'include/asm/ioctls.h',
+		subdir: 'asm',
+	)
+
+	install_headers(
+		'include/linux/fb.h',
+		subdir: 'linux',
+	)
+
+	install_headers(
+		'include/sys/reboot.h',
+		'include/sys/mount.h',
+		'include/sys/sysmacros.h',
+		subdir: 'sys',
+	)
+
+	install_headers(
+		'include/lyre/syscall.h',
+		'include/lyre/sockios.h',
+		subdir: 'lyre',
+	)
+
+	install_headers(
+		'include/mntent.h',
+		'include/utmpx.h',
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crt0.S mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crt0.S
new file mode 100644
index 0000000..ecf7740
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crt0.S
@@ -0,0 +1,8 @@
+.section .text
+.global _start
+_start:
+    mov %rsp, %rdi
+    lea main(%rip), %rsi
+    call __mlibc_entry
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crti.S mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crti.S
new file mode 100644
index 0000000..911b078
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crtn.S mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crtn.S
new file mode 100644
index 0000000..0187e50
--- /dev/null
+++ mlibc-workdir/sysdeps/lyre/x86_64/crt-src/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
